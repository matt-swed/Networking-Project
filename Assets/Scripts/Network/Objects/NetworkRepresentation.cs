using DarkRift;
using DarkRift.Server;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class NetworkRepresentation : NetworkObject
{
    #region Properties

    public Rigidbody rigidbodyReference;

    /// <summary>
    /// Last received message from the server
    /// </summary>
    public PlayerSyncMessageModel lastReceivedMessage;

    /// <summary>
    /// Tick counted by the client
    /// </summary>
    public int clientTick = -1;

    /// <summary>
    /// Contains data wich will be generated by the client
    /// </summary>
    public List<PlayerSyncMessageModel> reconciliationInfoList;
    #endregion

    // Start is called before the first frame update
    public override void Start()
    {
        base.Start();

        ////////////////////////////////////
        // Get references
        rigidbodyReference = GetComponent<Rigidbody>();

        //If we are on client side
        if (!Equals(ClientManager.instance, null))
        {
            //////////////////
            /// Suscribe to events
            ClientManager.instance.clientReference.MessageReceived += UpdateFromServerState;
            reconciliationInfoList = new List<PlayerSyncMessageModel>();
        }
    }

    private void OnDestroy()
    {
        //If we are on client side
        if (!Equals(ClientManager.instance, null))
        {
            ClientManager.instance.clientReference.MessageReceived -= UpdateFromServerState;
        }
    }

    private void FixedUpdate()
    {
        ////If we are on server side
        //if (!Equals(GameServerManager.instance, null))
        //{
        //    if (GameServerManager.instance.currentTick % 10 == 0)
        //        SendBallPositionToClients();
        //}
        if (!Equals(ClientManager.instance, null) && clientTick != -1)
        {
            reconciliationInfoList.Add(new PlayerSyncMessageModel
            {
                position = transform.position,
                serverTick = clientTick,
                velocity = rigidbodyReference.velocity
            });

            Reconciliate();
        }
    }

    /// <summary>
    /// This function receives messages meant to move the representations with their controllable player counterparts. 
    /// The function distinguishes between messages for different represenations using the networkID
    /// </summary>
    /// <param name="sender"></param>
    /// <param name="e"></param>
    private void UpdateFromServerState(object sender, DarkRift.Client.MessageReceivedEventArgs e)
    {
        //if we can a message with the tag for moving the representation
        if (e.Tag == NetworkTags.InGame.REP_SYNC_POS)
        {
            //Get message data
            PlayerSyncMessageModel syncMessage = e.GetMessage().Deserialize<PlayerSyncMessageModel>();

            //If this is the first time we receive the message
            if (Object.Equals(null, lastReceivedMessage) && id == syncMessage.networkID)
            {
                //Update data
                rigidbodyReference.velocity = syncMessage.velocity;
                rigidbodyReference.transform.position = syncMessage.position;
                clientTick = syncMessage.serverTick;
                lastReceivedMessage = syncMessage;
            }

            //If the message regards this object and is older than the previous one
            if (id == syncMessage.networkID && syncMessage.serverTick > lastReceivedMessage.serverTick)
            {
                lastReceivedMessage = syncMessage;
            }
        }
    }

    /// <summary>
    /// Reconciliate the client with the server data
    /// </summary>
    private void Reconciliate()
    {
        if (reconciliationInfoList.Count() > 0)
        {
            //Get the position of the client at this specific frame
            PlayerSyncMessageModel clientInfo = reconciliationInfoList.Where(i => i.serverTick == lastReceivedMessage.serverTick).FirstOrDefault();

            //If there is more than 50 tick that the ball has not been updated depending to the server position
            if (reconciliationInfoList.Count() > 50)
            {
                rigidbodyReference.velocity = lastReceivedMessage.velocity;
                rigidbodyReference.transform.position = lastReceivedMessage.position;
                clientTick = lastReceivedMessage.serverTick;
                clientInfo = lastReceivedMessage;
            }

            if (!Equals(clientInfo, null))
            {
                //Check for position divergence
                if (Vector3.Distance(clientInfo.position, lastReceivedMessage.position) >= 0.05f)
                {
                    //Update data
                    rigidbodyReference.velocity = lastReceivedMessage.velocity;
                    rigidbodyReference.transform.position = lastReceivedMessage.position;
                }

                //Empty the list
                reconciliationInfoList.Clear();
            }
        }
    }
}
